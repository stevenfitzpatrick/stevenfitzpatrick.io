<p>
	One of the main performance gains you can make these days is by controlling the amount of javascript you ship to your users.
	The idea is to stay away from shipping your entire javascript codebase into one bundle, which the user has re-download entirely
	on any code change. Plus the fact that the user is downloading javascript which may not even required by the page in question
	and may not ever be required.
</p>

<p>
	To help your users out, I will show a few techniques using Webpack and Preact to use code splitting to minimize the javascript
	the user is forced to download and dynamically load any further required bundles. Don&rsquo;t worry a lot of this sounds
	a lot scarier than it really is, Webpack does most out of this magic out of the box.
</p>

<h5>Code Splitting set up</h5>

<ul>
	<li><a target="_blank" rel="noopener noreferrer" class="link--content" href="https://developers.google.com/speed/webp/download">Webpack</a>		is the main requirement, and I am using version 3.0.0.</li>
	<li><code>import()</code> to dynamically load ES6 modules, will require your project to have babel set up and polyfill for <code>Promise()</code>.</li>
	<li><a target="_blank" rel="noopener noreferrer" class="link--content" href="https://developers.google.com/speed/webp/download">Preact Async Router</a>		is used for route based code splitting.</li>
</ul>

<h5>Route based Code Splitting</h5>

<p>Using Preact Async Router we can define our main page routes and define what Component to lazy-load when that route is requested.
</p>

<div class="breakout">
	<div class="breakout-wrapper">
		<Highlight type="xml" code="<Router>
  <Home path='/' />
  <AsyncRoute path=''/about'' getComponent={this.About} />
  <AsyncRoute path=''/favourites'' getComponent={this.Favourites} />
  <AsyncRoute path=''/writing'' getComponent={this.Writing}         />
</Router>"></Highlight>
	</div>
</div>

<p>Lazy load function for Route to call when called upon. Please note the comment within <code>import()</code>, this is a special
	feature to name your chunks accordingly.</p>

<div class="breakout">
	<div class="breakout-wrapper">
		<Highlight type="javascript" code="Favourites = async () => {
  const module = await import(
     /* webpackChunkName: ''chunk-favourite'' */ './favourites'
  );
  return module.default;
};">
		</Highlight>
	</div>
</div>

<h5>Component Code Splitting</h5>

<p>You might also run into a situation, where you want to lazy-load some logic but not based on routes but rather event driven.
	One common example in the Preact or React world might be based on a Component lifecycle event i.e. <code>ComponentDidMount</code>.</p>


<div class="breakout">
	<div class="breakout-wrapper">
		<Highlight type="javascript" code="async componentDidMount() {
  const contactMe = await import(
    /* webpackChunkName: ''chunk-contactme'' */ './Contact'
  );
  this.Contact = contactMe.default;
}

render() {
  ...
  // The && check is added here to prevent <undefined></undefined> being outputted.
  { this.Contact && <this.Contact displayShowMe={displayShowMe} /> }
  ...
}">
		</Highlight>
	</div>
</div>

<p>Another example might be based on a user event like clicking a button, this works similar to the above example but we just
	use <code>componentWillReceiveProps</code> lifecycle event.</p>

<div class="breakout">
	<div class="breakout-wrapper">
		<Highlight type="javascript" code="async componentWillReceiveProps(nextProps) {
  if (nextProps.displayShowMe && !this.Contact) {
    const contactMe = await import(
      /* webpackChunkName: ''chunk-contactme'' */ './Contact'
    );
    this.Contact = contactMe.default;
    // forceUpdate() required to call render
    this.forceUpdate();
  }
}

render({ showAboutMe, displayShowMe }) {
  <button onClick={showAboutMe} />
  {this.Contact && <this.Contact displayShowMe={displayShowMe} />}
}">
		</Highlight>
	</div>
</div>